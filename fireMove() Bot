#include "headerFile.h"

//Requires: Valid PLAYER objects for currentPlayer and opposingPlayer and valid INPUT object input.
//Returns: Updates hit or miss on the grid and adjusts targeting strategy based on previous hits.

void fireMove(PLAYER* currentPlayer, PLAYER* opposingPlayer,INPUT* input)
{
   int row, col;
    static int lastHitRow = -1, lastHitCol = -1; // Ensure lastHitRow and lastHitCol are initialized
    static int prevRow = -1, prevCol = -1; // Store previous hit coordinates to determine orientation
    static int isVertical = -1; // To determine if the ship is vertical (1) or horizontal (0)
    
    // If the bot has already hit a ship, focus on surrounding cells (targeting phase)
    if (lastHitRow != -1 && lastHitCol != -1) {
        // Check orientation if there's a previous hit
        if (prevRow != -1 && prevCol != -1) {
            if (lastHitRow == prevRow) { 
                // Horizontal hit: prioritize adjacent cells in the same row
                if (isValidAndUnguessed(currentPlayer, lastHitRow, lastHitCol-1)) {
                    row = lastHitRow;
                    col = lastHitCol - 1;
                    isVertical = 0;  // Set orientation to horizontal
                } else if (isValidAndUnguessed(currentPlayer, lastHitRow, lastHitCol+1)) {
                    row = lastHitRow;
                    col = lastHitCol + 1;
                    isVertical = 0; 
                }
            } else if (lastHitCol == prevCol) {
                // Vertical hit: prioritize adjacent cells in the same column
                if (isValidAndUnguessed(currentPlayer, lastHitRow-1, lastHitCol)) {
                    row = lastHitRow - 1;
                    col = lastHitCol;
                    isVertical = 1;  // Set orientation to vertical
                } else if (isValidAndUnguessed(currentPlayer, lastHitRow+1, lastHitCol)) {
                    row = lastHitRow + 1;
                    col = lastHitCol;
                    isVertical = 1;  
                }
            }
        }

        // If no adjacent cells were found (either hit ends or blocked by boundaries), start random searching
        if (row == -1 || col == -1) {
            if (isVertical == 1) {
                // Vertical targeting: Try rows above and below
                if (isValidAndUnguessed(currentPlayer, lastHitRow-1, lastHitCol)) {
                    row = lastHitRow - 1;
                    col = lastHitCol;
                } else if (isValidAndUnguessed(currentPlayer, lastHitRow+1, lastHitCol)) {
                    row = lastHitRow + 1;
                    col = lastHitCol;
                }
            } else if (isVertical == 0) {
                // Horizontal targeting: Try columns left and right
                if (isValidAndUnguessed(currentPlayer, lastHitRow, lastHitCol-1)) {
                    row = lastHitRow;
                    col = lastHitCol - 1;
                } else if (isValidAndUnguessed(currentPlayer, lastHitRow, lastHitCol+1)) {
                    row = lastHitRow;
                    col = lastHitCol + 1;
                }
            } else {
                // Searching Phase: Randomly pick a cell that has not been guessed yet
                do {
                    row = rand() % 10; // Random row (0-9)
                    col = rand() % 10; // Random column (0-9)
                } while (opposingPlayer->hitsAndMissesGrid[row][col] != ' '); // Repeat if already fired 
            }
        }
    } else {
        // If there has been no hit yet, choose randomly 
        do {
            row = rand() % 10; 
            col = rand() % 10; 
        } while (opposingPlayer->hitsAndMissesGrid[row][col] != ' ');
    }

    // Check hit or miss
    if (opposingPlayer->grid[row][col] == 'X')
    {
        if(currentPlayer->hitsAndMissesGrid[row][col]=='*') // Hit is already present
        {
            printf("congrats on hitting the same place twice!\n");
            return;
        } 
        printf("Hit!\n");
        currentPlayer->hitsAndMissesGrid[row][col] = '*'; // Mark the location of the hit
        addHitOnShip(currentPlayer,opposingPlayer,input);
    }
    else
    {
        if(currentPlayer->hitsAndMissesGrid[row][col]=='o')
        {
            if(difficulty=EASY)
            {
                printf("why?\n");
                return;
            }
        }
        printf("Miss.\n");
       currentPlayer->hitsAndMissesGrid[row][col] = 'o'; // Mark the miss
    }

}

//Requires: Valid PLAYER objects for currentPlayer and opposingPlayer and valid INPUT object input.
//Returns: Updates a hit on ship and marks ship fallen if all its parts are hit

void addHitOnShip(PLAYER* currentPlayer,PLAYER* opposingPlayer, INPUT* input)
{

    int hitCoord = input->row*10+input->column; //Converting coordinates to integers
    SHIP* currentShip ;
    //Loop over each ship 
    for(int  i =0;i< NUMBEROFSHIPS; i++)
    {
        currentShip= &opposingPlayer->ships[i];
        if(currentShip->hasFallen==1) //Kkip if the ship has fallen
        {
            continue;
        }

        for(int  j = 0 ; j < currentShip->size;j++)
        {

            if(currentShip->coord[j]==hitCoord)
            {
                currentShip->hits++;

                if(currentShip->hits == currentShip->size)
                {
                    printf("%s has fallen!\n",currentShip->name); //ship is destroyed
                    currentShip->hasFallen=1;
                    shipFallen(currentPlayer,opposingPlayer,input); //reprecussions of a fallenSHIP


                }
                
            }
        }

        
    }
}
//Requires: Valid PLAYER objects for currentPlayer and opposingPlayer.
//Returns: Reduces the opponent's shipsLeft and enables artillery and torpedo moves for the current player if.

void shipFallen(PLAYER* currentPlayer,PLAYER* opposingPlayer, INPUT* input)
{
    
    opposingPlayer->shipsLeft--;
    currentPlayer->artillery =1;

    if(opposingPlayer->shipsLeft==1)
    {
        currentPlayer->torpedo=1;
    }
}

//Require: Valid PLAYER object currentPlayer and coordinates of row and col within grid bounds (0-9).
//Returns: Returns 1 if the coordinate is valid and unguessed, otherwise 0.

int isValidAndUnguessed(PLAYER* currentPlayer, int row, int col) {
    if (row >= 0 && row < 10 && col >= 0 && col < 10) {
        if (currentPlayer->hitsAndMissesGrid[row][col] == ' ') {
            return 1; // Valid and unguessed
        }
    }
    return 0; // Invalid or already guessed
}
